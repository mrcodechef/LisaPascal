// This file was automatically generated by EbnfStudio; don't modify it!
#include "LisaParser.h"
using namespace Lisa;

static inline bool FIRST_LisaPascal(int tt) {
	switch(tt){
	case Tok_program:
	case Tok_unit:
	case Tok_begin:
	case Tok_end:
	case Tok_function:
	case Tok_procedure:
		return true;
	default: return false;
	}
}

static inline bool FIRST_program_(int tt) {
	return tt == Tok_program;
}

static inline bool FIRST_program_heading(int tt) {
	return tt == Tok_program;
}

static inline bool FIRST_program_parameters(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_uses_clause(int tt) {
	return tt == Tok_uses;
}

static inline bool FIRST_identifier_list2(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_regular_unit(int tt) {
	return tt == Tok_unit;
}

static inline bool FIRST_unit_heading(int tt) {
	return tt == Tok_unit;
}

static inline bool FIRST_interface_part(int tt) {
	return tt == Tok_interface;
}

static inline bool FIRST_implementation_part(int tt) {
	return tt == Tok_implementation;
}

static inline bool FIRST_non_regular_unit(int tt) {
	return tt == Tok_begin || tt == Tok_end || tt == Tok_function || tt == Tok_procedure;
}

static inline bool FIRST_block(int tt) {
	switch(tt){
	case Tok_const:
	case Tok_var:
	case Tok_label:
	case Tok_function:
	case Tok_type:
	case Tok_procedure:
		return true;
	default: return false;
	}
}

static inline bool FIRST_label_declaration_part(int tt) {
	return tt == Tok_label;
}

static inline bool FIRST_label_(int tt) {
	return tt == Tok_digit_sequence;
}

static inline bool FIRST_constant_declaration_part(int tt) {
	return tt == Tok_const;
}

static inline bool FIRST_constant_declaration(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_constant(int tt) {
	switch(tt){
	case Tok_hex_digit_sequence:
	case Tok_string_literal:
	case Tok_Plus:
	case Tok_unsigned_real:
	case Tok_digit_sequence:
	case Tok_Minus:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_type_declaration_part(int tt) {
	return tt == Tok_type;
}

static inline bool FIRST_type_declaration(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_variable_declaration_part(int tt) {
	return tt == Tok_var;
}

static inline bool FIRST_variable_declaration(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_procedure_and_function_interface_part(int tt) {
	return tt == Tok_function || tt == Tok_procedure;
}

static inline bool FIRST_procedure_and_function_declaration_part(int tt) {
	return tt == Tok_function || tt == Tok_procedure;
}

static inline bool FIRST_subroutine_part(int tt) {
	return tt == Tok_function || tt == Tok_procedure || tt == Tok_methods;
}

static inline bool FIRST_method_block(int tt) {
	return tt == Tok_methods;
}

static inline bool FIRST_procedure_declaration(int tt) {
	return tt == Tok_procedure;
}

static inline bool FIRST_body_(int tt) {
	switch(tt){
	case Tok_const:
	case Tok_var:
	case Tok_begin:
	case Tok_forward:
	case Tok_inline:
	case Tok_label:
	case Tok_function:
	case Tok_type:
	case Tok_external:
	case Tok_procedure:
		return true;
	default: return false;
	}
}

static inline bool FIRST_function_declaration(int tt) {
	return tt == Tok_function;
}

static inline bool FIRST_statement_part(int tt) {
	return tt == Tok_begin;
}

static inline bool FIRST_procedure_heading(int tt) {
	return tt == Tok_procedure;
}

static inline bool FIRST_function_heading(int tt) {
	return tt == Tok_function;
}

static inline bool FIRST_result_type(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_formal_parameter_list(int tt) {
	return tt == Tok_Lpar;
}

static inline bool FIRST_formal_parameter_section(int tt) {
	return tt == Tok_var || tt == Tok_function || tt == Tok_procedure || tt == Tok_identifier;
}

static inline bool FIRST_parameter_declaration(int tt) {
	return tt == Tok_var || tt == Tok_identifier;
}

static inline bool FIRST_statement_sequence(int tt) {
	switch(tt){
	case Tok_Semi:
	case Tok_with:
	case Tok_if:
	case Tok_digit_sequence:
	case Tok_begin:
	case Tok_for:
	case Tok_while:
	case Tok_goto:
	case Tok_repeat:
	case Tok_case:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_statement(int tt) {
	switch(tt){
	case Tok_with:
	case Tok_if:
	case Tok_digit_sequence:
	case Tok_begin:
	case Tok_for:
	case Tok_while:
	case Tok_goto:
	case Tok_repeat:
	case Tok_case:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_simple_statement(int tt) {
	return tt == Tok_goto || tt == Tok_identifier;
}

static inline bool FIRST_assigOrCall(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_goto_statement(int tt) {
	return tt == Tok_goto;
}

static inline bool FIRST_structured_statement(int tt) {
	switch(tt){
	case Tok_with:
	case Tok_if:
	case Tok_begin:
	case Tok_for:
	case Tok_while:
	case Tok_repeat:
	case Tok_case:
		return true;
	default: return false;
	}
}

static inline bool FIRST_compound_statement(int tt) {
	return tt == Tok_begin;
}

static inline bool FIRST_repetitive_statement(int tt) {
	return tt == Tok_for || tt == Tok_while || tt == Tok_repeat;
}

static inline bool FIRST_while_statement(int tt) {
	return tt == Tok_while;
}

static inline bool FIRST_repeat_statement(int tt) {
	return tt == Tok_repeat;
}

static inline bool FIRST_for_statement(int tt) {
	return tt == Tok_for;
}

static inline bool FIRST_initial_value(int tt) {
	switch(tt){
	case Tok_hex_digit_sequence:
	case Tok_Plus:
	case Tok_string_literal:
	case Tok_Lbrack:
	case Tok_digit_sequence:
	case Tok_unsigned_real:
	case Tok_Lpar:
	case Tok_not:
	case Tok_Minus:
	case Tok_At:
	case Tok_nil:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_final_value(int tt) {
	switch(tt){
	case Tok_hex_digit_sequence:
	case Tok_Plus:
	case Tok_string_literal:
	case Tok_Lbrack:
	case Tok_digit_sequence:
	case Tok_unsigned_real:
	case Tok_Lpar:
	case Tok_not:
	case Tok_Minus:
	case Tok_At:
	case Tok_nil:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_conditional_statement(int tt) {
	return tt == Tok_if || tt == Tok_case;
}

static inline bool FIRST_if_statement(int tt) {
	return tt == Tok_if;
}

static inline bool FIRST_case_statement(int tt) {
	return tt == Tok_case;
}

static inline bool FIRST_case_limb(int tt) {
	switch(tt){
	case Tok_hex_digit_sequence:
	case Tok_string_literal:
	case Tok_Plus:
	case Tok_unsigned_real:
	case Tok_digit_sequence:
	case Tok_Minus:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_case_label_list(int tt) {
	switch(tt){
	case Tok_hex_digit_sequence:
	case Tok_string_literal:
	case Tok_Plus:
	case Tok_digit_sequence:
	case Tok_unsigned_real:
	case Tok_Minus:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_otherwise_clause(int tt) {
	return tt == Tok_Semi || tt == Tok_otherwise;
}

static inline bool FIRST_with_statement(int tt) {
	return tt == Tok_with;
}

static inline bool FIRST_actual_parameter_list(int tt) {
	return tt == Tok_Lpar;
}

static inline bool FIRST_actual_parameter(int tt) {
	switch(tt){
	case Tok_hex_digit_sequence:
	case Tok_Plus:
	case Tok_string_literal:
	case Tok_Lbrack:
	case Tok_digit_sequence:
	case Tok_unsigned_real:
	case Tok_Lpar:
	case Tok_not:
	case Tok_Minus:
	case Tok_At:
	case Tok_nil:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_expression(int tt) {
	switch(tt){
	case Tok_hex_digit_sequence:
	case Tok_Plus:
	case Tok_string_literal:
	case Tok_Lbrack:
	case Tok_digit_sequence:
	case Tok_unsigned_real:
	case Tok_Lpar:
	case Tok_not:
	case Tok_Minus:
	case Tok_At:
	case Tok_nil:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_simple_expression(int tt) {
	switch(tt){
	case Tok_hex_digit_sequence:
	case Tok_Plus:
	case Tok_string_literal:
	case Tok_Lbrack:
	case Tok_unsigned_real:
	case Tok_digit_sequence:
	case Tok_Lpar:
	case Tok_not:
	case Tok_Minus:
	case Tok_At:
	case Tok_nil:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_term(int tt) {
	switch(tt){
	case Tok_hex_digit_sequence:
	case Tok_string_literal:
	case Tok_Lbrack:
	case Tok_digit_sequence:
	case Tok_unsigned_real:
	case Tok_Lpar:
	case Tok_not:
	case Tok_At:
	case Tok_nil:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_factor(int tt) {
	switch(tt){
	case Tok_hex_digit_sequence:
	case Tok_string_literal:
	case Tok_Lbrack:
	case Tok_unsigned_real:
	case Tok_digit_sequence:
	case Tok_Lpar:
	case Tok_not:
	case Tok_At:
	case Tok_nil:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_relational_operator(int tt) {
	switch(tt){
	case Tok_Geq:
	case Tok_Lt:
	case Tok_Eq:
	case Tok_Gt:
	case Tok_Leq:
	case Tok_in:
	case Tok_LtGt:
		return true;
	default: return false;
	}
}

static inline bool FIRST_addition_operator(int tt) {
	return tt == Tok_Plus || tt == Tok_or || tt == Tok_Minus;
}

static inline bool FIRST_multiplication_operator(int tt) {
	switch(tt){
	case Tok_and:
	case Tok_mod:
	case Tok_Slash:
	case Tok_Colon:
	case Tok_Star:
	case Tok_div:
		return true;
	default: return false;
	}
}

static inline bool FIRST_variable_reference(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_qualifier(int tt) {
	return tt == Tok_Hat || tt == Tok_Lbrack || tt == Tok_Dot;
}

static inline bool FIRST_index(int tt) {
	return tt == Tok_Lbrack;
}

static inline bool FIRST_field_designator(int tt) {
	return tt == Tok_Dot;
}

static inline bool FIRST_dereferencer(int tt) {
	return tt == Tok_Hat;
}

static inline bool FIRST_set_literal(int tt) {
	return tt == Tok_Lbrack;
}

static inline bool FIRST_member_group(int tt) {
	switch(tt){
	case Tok_hex_digit_sequence:
	case Tok_Plus:
	case Tok_string_literal:
	case Tok_Lbrack:
	case Tok_unsigned_real:
	case Tok_digit_sequence:
	case Tok_Lpar:
	case Tok_not:
	case Tok_Minus:
	case Tok_At:
	case Tok_nil:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_type_(int tt) {
	switch(tt){
	case Tok_Hat:
	case Tok_hex_digit_sequence:
	case Tok_string:
	case Tok_record:
	case Tok_array:
	case Tok_string_literal:
	case Tok_Plus:
	case Tok_digit_sequence:
	case Tok_unsigned_real:
	case Tok_Lpar:
	case Tok_set:
	case Tok_Minus:
	case Tok_packed:
	case Tok_file:
	case Tok_identifier:
	case Tok_subclass:
		return true;
	default: return false;
	}
}

static inline bool FIRST_simple_type(int tt) {
	switch(tt){
	case Tok_hex_digit_sequence:
	case Tok_string_literal:
	case Tok_Plus:
	case Tok_unsigned_real:
	case Tok_digit_sequence:
	case Tok_Lpar:
	case Tok_Minus:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_ordinal_type(int tt) {
	switch(tt){
	case Tok_hex_digit_sequence:
	case Tok_string_literal:
	case Tok_Plus:
	case Tok_unsigned_real:
	case Tok_digit_sequence:
	case Tok_Lpar:
	case Tok_Minus:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_string_type(int tt) {
	return tt == Tok_string;
}

static inline bool FIRST_size_attribute(int tt) {
	return tt == Tok_hex_digit_sequence || tt == Tok_digit_sequence || tt == Tok_identifier;
}

static inline bool FIRST_enumerated_type(int tt) {
	return tt == Tok_Lpar;
}

static inline bool FIRST_subrange_type(int tt) {
	switch(tt){
	case Tok_hex_digit_sequence:
	case Tok_string_literal:
	case Tok_Plus:
	case Tok_digit_sequence:
	case Tok_unsigned_real:
	case Tok_Minus:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_structured_type(int tt) {
	switch(tt){
	case Tok_record:
	case Tok_array:
	case Tok_set:
	case Tok_packed:
	case Tok_file:
	case Tok_subclass:
		return true;
	default: return false;
	}
}

static inline bool FIRST_array_type(int tt) {
	return tt == Tok_array;
}

static inline bool FIRST_index_type(int tt) {
	switch(tt){
	case Tok_hex_digit_sequence:
	case Tok_string_literal:
	case Tok_Plus:
	case Tok_unsigned_real:
	case Tok_digit_sequence:
	case Tok_Lpar:
	case Tok_Minus:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_set_type(int tt) {
	return tt == Tok_set;
}

static inline bool FIRST_file_type(int tt) {
	return tt == Tok_file;
}

static inline bool FIRST_pointer_type(int tt) {
	return tt == Tok_Hat;
}

static inline bool FIRST_class_type(int tt) {
	return tt == Tok_subclass;
}

static inline bool FIRST_method_interface(int tt) {
	return tt == Tok_function || tt == Tok_procedure;
}

static inline bool FIRST_record_type(int tt) {
	return tt == Tok_record;
}

static inline bool FIRST_field_list(int tt) {
	return tt == Tok_case || tt == Tok_identifier;
}

static inline bool FIRST_fixed_part(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_field_declaration(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_variant_part(int tt) {
	return tt == Tok_case;
}

static inline bool FIRST_tag_field(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_variant(int tt) {
	switch(tt){
	case Tok_hex_digit_sequence:
	case Tok_string_literal:
	case Tok_Plus:
	case Tok_unsigned_real:
	case Tok_digit_sequence:
	case Tok_Minus:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_field_identifier(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_variable_identifier(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_type_identifier(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_identifier_list(int tt) {
	return tt == Tok_identifier;
}

static inline bool FIRST_expression_list(int tt) {
	switch(tt){
	case Tok_hex_digit_sequence:
	case Tok_Plus:
	case Tok_string_literal:
	case Tok_Lbrack:
	case Tok_unsigned_real:
	case Tok_digit_sequence:
	case Tok_Lpar:
	case Tok_not:
	case Tok_Minus:
	case Tok_At:
	case Tok_nil:
	case Tok_identifier:
		return true;
	default: return false;
	}
}

static inline bool FIRST_unsigned_integer(int tt) {
	return tt == Tok_hex_digit_sequence || tt == Tok_digit_sequence;
}

static inline bool FIRST_unsigned_number(int tt) {
	return tt == Tok_hex_digit_sequence || tt == Tok_digit_sequence || tt == Tok_unsigned_real;
}

static inline bool FIRST_sign(int tt) {
	return tt == Tok_Plus || tt == Tok_Minus;
}

void Parser::RunParser() {
	root = SynTree();
	errors.clear();
	next();
	LisaPascal(&root);
}

void Parser::next() {
	cur = la;
	la = scanner->next();
	while( la.d_type == Tok_Invalid ) {
		errors << Error(la.d_val, la.d_lineNr, la.d_colNr, la.d_sourcePath);
		la = scanner->next();
	}
}

Token Parser::peek(int off) {
	if( off == 1 )
		return la;
	else if( off == 0 )
		return cur;
	else
		return scanner->peek(off-1);
}

void Parser::invalid(const char* what) {
	errors << Error(QString("invalid %1").arg(what),la.d_lineNr, la.d_colNr, la.d_sourcePath);
}

bool Parser::expect(int tt, bool pkw, const char* where) {
	if( la.d_type == tt) { next(); return true; }
	else { errors << Error(QString("'%1' expected in %2").arg(tokenTypeString(tt)).arg(where),la.d_lineNr, la.d_colNr, la.d_sourcePath); return false; }
}

static inline void dummy() {}

	void Parser::addTerminal(SynTree* st) {
		if( cur.d_type != Tok_Semi && cur.d_type != Tok_Comma && cur.d_type != Tok_Dot ){
			SynTree* tmp = new SynTree( cur ); st->d_children.append(tmp);
		}
	}
void Parser::LisaPascal(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_LisaPascal, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_program_(la.d_type) ) {
		program_(st);
	} else if( FIRST_regular_unit(la.d_type) ) {
		regular_unit(st);
	} else if( FIRST_non_regular_unit(la.d_type) ) {
		non_regular_unit(st);
	} else
		invalid("LisaPascal");
}

void Parser::program_(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_program_, la); st->d_children.append(tmp); st = tmp; }
	program_heading(st);
	if( expect(Tok_Semi, false, "program_") ) addTerminal(st);
	if( FIRST_uses_clause(la.d_type) ) {
		uses_clause(st);
	}
	block(st);
	if( FIRST_statement_part(la.d_type) ) {
		statement_part(st);
		if( expect(Tok_Dot, false, "program_") ) addTerminal(st);
	}
}

void Parser::program_heading(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_program_heading, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_program, false, "program_heading") ) addTerminal(st);
	if( expect(Tok_identifier, false, "program_heading") ) addTerminal(st);
	if( la.d_type == Tok_Lpar ) {
		if( expect(Tok_Lpar, false, "program_heading") ) addTerminal(st);
		program_parameters(st);
		if( expect(Tok_Rpar, false, "program_heading") ) addTerminal(st);
	}
}

void Parser::program_parameters(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_program_parameters, la); st->d_children.append(tmp); st = tmp; }
	identifier_list(st);
}

void Parser::uses_clause(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_uses_clause, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_uses, false, "uses_clause") ) addTerminal(st);
	identifier_list2(st);
	if( expect(Tok_Semi, false, "uses_clause") ) addTerminal(st);
}

void Parser::identifier_list2(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_identifier_list2, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_identifier, false, "identifier_list2") ) addTerminal(st);
	if( la.d_type == Tok_Slash ) {
		if( expect(Tok_Slash, false, "identifier_list2") ) addTerminal(st);
		if( expect(Tok_identifier, false, "identifier_list2") ) addTerminal(st);
	}
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "identifier_list2") ) addTerminal(st);
		if( expect(Tok_identifier, false, "identifier_list2") ) addTerminal(st);
		if( la.d_type == Tok_Slash ) {
			if( expect(Tok_Slash, false, "identifier_list2") ) addTerminal(st);
			if( expect(Tok_identifier, false, "identifier_list2") ) addTerminal(st);
		}
	}
}

void Parser::regular_unit(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_regular_unit, la); st->d_children.append(tmp); st = tmp; }
	unit_heading(st);
	if( expect(Tok_Semi, false, "regular_unit") ) addTerminal(st);
	if( la.d_type == Tok_intrinsic ) {
		if( expect(Tok_intrinsic, false, "regular_unit") ) addTerminal(st);
		if( la.d_type == Tok_shared ) {
			if( expect(Tok_shared, false, "regular_unit") ) addTerminal(st);
		}
		if( expect(Tok_Semi, false, "regular_unit") ) addTerminal(st);
	}
	interface_part(st);
	implementation_part(st);
	if( la.d_type == Tok_end ) {
		if( expect(Tok_end, false, "regular_unit") ) addTerminal(st);
		if( expect(Tok_Dot, false, "regular_unit") ) addTerminal(st);
	}
}

void Parser::unit_heading(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_unit_heading, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_unit, false, "unit_heading") ) addTerminal(st);
	if( expect(Tok_identifier, false, "unit_heading") ) addTerminal(st);
}

void Parser::interface_part(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_interface_part, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_interface, false, "interface_part") ) addTerminal(st);
	if( FIRST_uses_clause(la.d_type) ) {
		uses_clause(st);
	}
	while( FIRST_constant_declaration_part(la.d_type) || FIRST_type_declaration_part(la.d_type) || FIRST_variable_declaration_part(la.d_type) || FIRST_procedure_and_function_interface_part(la.d_type) ) {
		if( FIRST_constant_declaration_part(la.d_type) ) {
			constant_declaration_part(st);
		} else if( FIRST_type_declaration_part(la.d_type) ) {
			type_declaration_part(st);
		} else if( FIRST_variable_declaration_part(la.d_type) ) {
			variable_declaration_part(st);
		} else if( FIRST_procedure_and_function_interface_part(la.d_type) || la.d_type == Tok_procedure || la.d_type == Tok_const || la.d_type == Tok_var || la.d_type == Tok_implementation || la.d_type == Tok_function || la.d_type == Tok_type ) {
			procedure_and_function_interface_part(st);
		} else
			invalid("interface_part");
	}
}

void Parser::implementation_part(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_implementation_part, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_implementation, false, "implementation_part") ) addTerminal(st);
	while( FIRST_constant_declaration_part(la.d_type) || FIRST_type_declaration_part(la.d_type) || FIRST_variable_declaration_part(la.d_type) || FIRST_subroutine_part(la.d_type) ) {
		if( FIRST_constant_declaration_part(la.d_type) ) {
			constant_declaration_part(st);
		} else if( FIRST_type_declaration_part(la.d_type) ) {
			type_declaration_part(st);
		} else if( FIRST_variable_declaration_part(la.d_type) ) {
			variable_declaration_part(st);
		} else if( FIRST_subroutine_part(la.d_type) || la.d_type == Tok_methods || la.d_type == Tok_procedure || la.d_type == Tok_const || la.d_type == Tok_var || la.d_type == Tok_function || la.d_type == Tok_end || la.d_type == Tok_type ) {
			subroutine_part(st);
		} else
			invalid("implementation_part");
	}
}

void Parser::non_regular_unit(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_non_regular_unit, la); st->d_children.append(tmp); st = tmp; }
	while( ( ( peek(1).d_type == Tok_procedure || peek(1).d_type == Tok_function ) )  ) {
		procedure_and_function_declaration_part(st);
	}
	if( FIRST_statement_part(la.d_type) || la.d_type == Tok_end ) {
		if( FIRST_statement_part(la.d_type) ) {
			statement_part(st);
			if( expect(Tok_Dot, false, "non_regular_unit") ) addTerminal(st);
		} else if( la.d_type == Tok_end ) {
			if( expect(Tok_end, false, "non_regular_unit") ) addTerminal(st);
			if( expect(Tok_Dot, false, "non_regular_unit") ) addTerminal(st);
		} else
			invalid("non_regular_unit");
	}
}

void Parser::block(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_block, la); st->d_children.append(tmp); st = tmp; }
	while( FIRST_label_declaration_part(la.d_type) || FIRST_constant_declaration_part(la.d_type) || FIRST_type_declaration_part(la.d_type) || FIRST_variable_declaration_part(la.d_type) || FIRST_procedure_and_function_declaration_part(la.d_type) ) {
		if( FIRST_label_declaration_part(la.d_type) ) {
			label_declaration_part(st);
		} else if( FIRST_constant_declaration_part(la.d_type) ) {
			constant_declaration_part(st);
		} else if( FIRST_type_declaration_part(la.d_type) ) {
			type_declaration_part(st);
		} else if( FIRST_variable_declaration_part(la.d_type) ) {
			variable_declaration_part(st);
		} else if( FIRST_procedure_and_function_declaration_part(la.d_type) || la.d_type == Tok_end || la.d_type == Tok_procedure || la.d_type == Tok_const || la.d_type == Tok_var || la.d_type == Tok_begin || la.d_type == Tok_end || la.d_type == Tok_label || la.d_type == Tok_function || la.d_type == Tok_type ) {
			procedure_and_function_declaration_part(st);
		} else
			invalid("block");
	}
}

void Parser::label_declaration_part(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_label_declaration_part, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_label, false, "label_declaration_part") ) addTerminal(st);
	label_(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "label_declaration_part") ) addTerminal(st);
		label_(st);
	}
	if( expect(Tok_Semi, false, "label_declaration_part") ) addTerminal(st);
}

void Parser::label_(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_label_, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_digit_sequence, false, "label_") ) addTerminal(st);
}

void Parser::constant_declaration_part(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_constant_declaration_part, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_const, false, "constant_declaration_part") ) addTerminal(st);
	constant_declaration(st);
	while( FIRST_constant_declaration(la.d_type) ) {
		constant_declaration(st);
	}
}

void Parser::constant_declaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_constant_declaration, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_identifier, false, "constant_declaration") ) addTerminal(st);
	if( expect(Tok_Eq, false, "constant_declaration") ) addTerminal(st);
	expression(st);
	if( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "constant_declaration") ) addTerminal(st);
	}
}

void Parser::constant(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_constant, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_sign(la.d_type) || la.d_type == Tok_identifier || FIRST_unsigned_number(la.d_type) ) {
		if( FIRST_sign(la.d_type) ) {
			sign(st);
		}
		if( la.d_type == Tok_identifier ) {
			if( expect(Tok_identifier, false, "constant") ) addTerminal(st);
			if( FIRST_actual_parameter_list(la.d_type) ) {
				actual_parameter_list(st);
			}
		} else if( FIRST_unsigned_number(la.d_type) ) {
			unsigned_number(st);
		} else
			invalid("constant");
	} else if( la.d_type == Tok_string_literal ) {
		if( expect(Tok_string_literal, false, "constant") ) addTerminal(st);
	} else
		invalid("constant");
}

void Parser::type_declaration_part(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_type_declaration_part, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_type, false, "type_declaration_part") ) addTerminal(st);
	type_declaration(st);
	while( FIRST_type_declaration(la.d_type) ) {
		type_declaration(st);
	}
}

void Parser::type_declaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_type_declaration, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_identifier, false, "type_declaration") ) addTerminal(st);
	if( expect(Tok_Eq, false, "type_declaration") ) addTerminal(st);
	type_(st);
	if( expect(Tok_Semi, false, "type_declaration") ) addTerminal(st);
}

void Parser::variable_declaration_part(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_variable_declaration_part, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_var, false, "variable_declaration_part") ) addTerminal(st);
	variable_declaration(st);
	while( FIRST_variable_declaration(la.d_type) ) {
		variable_declaration(st);
	}
}

void Parser::variable_declaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_variable_declaration, la); st->d_children.append(tmp); st = tmp; }
	identifier_list(st);
	if( expect(Tok_Colon, false, "variable_declaration") ) addTerminal(st);
	type_(st);
	if( expect(Tok_Semi, false, "variable_declaration") ) addTerminal(st);
}

void Parser::procedure_and_function_interface_part(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_procedure_and_function_interface_part, la); st->d_children.append(tmp); st = tmp; }
	while( FIRST_procedure_heading(la.d_type) || FIRST_function_heading(la.d_type) ) {
		if( FIRST_procedure_heading(la.d_type) ) {
			procedure_heading(st);
			if( expect(Tok_Semi, false, "procedure_and_function_interface_part") ) addTerminal(st);
		} else if( FIRST_function_heading(la.d_type) ) {
			function_heading(st);
			if( expect(Tok_Semi, false, "procedure_and_function_interface_part") ) addTerminal(st);
		} else
			invalid("procedure_and_function_interface_part");
	}
}

void Parser::procedure_and_function_declaration_part(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_procedure_and_function_declaration_part, la); st->d_children.append(tmp); st = tmp; }
	while( FIRST_procedure_declaration(la.d_type) || FIRST_function_declaration(la.d_type) ) {
		if( FIRST_procedure_declaration(la.d_type) ) {
			procedure_declaration(st);
		} else if( FIRST_function_declaration(la.d_type) ) {
			function_declaration(st);
		} else
			invalid("procedure_and_function_declaration_part");
	}
}

void Parser::subroutine_part(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_subroutine_part, la); st->d_children.append(tmp); st = tmp; }
	while( FIRST_procedure_declaration(la.d_type) || FIRST_function_declaration(la.d_type) || FIRST_method_block(la.d_type) ) {
		if( FIRST_procedure_declaration(la.d_type) ) {
			procedure_declaration(st);
		} else if( FIRST_function_declaration(la.d_type) ) {
			function_declaration(st);
		} else if( FIRST_method_block(la.d_type) ) {
			method_block(st);
		} else
			invalid("subroutine_part");
	}
}

void Parser::method_block(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_method_block, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_methods, false, "method_block") ) addTerminal(st);
	if( expect(Tok_of, false, "method_block") ) addTerminal(st);
	if( expect(Tok_identifier, false, "method_block") ) addTerminal(st);
	if( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "method_block") ) addTerminal(st);
	}
	if( FIRST_procedure_and_function_declaration_part(la.d_type) ) {
		procedure_and_function_declaration_part(st);
	}
	if( FIRST_statement_part(la.d_type) ) {
		statement_part(st);
	} else if( la.d_type == Tok_end ) {
		if( expect(Tok_end, false, "method_block") ) addTerminal(st);
	} else
		invalid("method_block");
	if( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "method_block") ) addTerminal(st);
	}
}

void Parser::procedure_declaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_procedure_declaration, la); st->d_children.append(tmp); st = tmp; }
	procedure_heading(st);
	if( expect(Tok_Semi, false, "procedure_declaration") ) addTerminal(st);
	body_(st);
	if( expect(Tok_Semi, false, "procedure_declaration") ) addTerminal(st);
}

void Parser::body_(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_body_, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_block(la.d_type) || FIRST_statement_part(la.d_type) ) {
		block(st);
		statement_part(st);
	} else if( la.d_type == Tok_forward ) {
		if( expect(Tok_forward, true, "body_") ) addTerminal(st);
	} else if( la.d_type == Tok_external ) {
		if( expect(Tok_external, true, "body_") ) addTerminal(st);
	} else if( la.d_type == Tok_inline ) {
		if( expect(Tok_inline, true, "body_") ) addTerminal(st);
		constant(st);
	} else
		invalid("body_");
}

void Parser::function_declaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_function_declaration, la); st->d_children.append(tmp); st = tmp; }
	function_heading(st);
	if( expect(Tok_Semi, false, "function_declaration") ) addTerminal(st);
	body_(st);
	if( expect(Tok_Semi, false, "function_declaration") ) addTerminal(st);
}

void Parser::statement_part(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_statement_part, la); st->d_children.append(tmp); st = tmp; }
	compound_statement(st);
}

void Parser::procedure_heading(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_procedure_heading, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_procedure, false, "procedure_heading") ) addTerminal(st);
	if( expect(Tok_identifier, false, "procedure_heading") ) addTerminal(st);
	if( la.d_type == Tok_Dot ) {
		if( expect(Tok_Dot, false, "procedure_heading") ) addTerminal(st);
		if( expect(Tok_identifier, false, "procedure_heading") ) addTerminal(st);
	}
	if( FIRST_formal_parameter_list(la.d_type) ) {
		formal_parameter_list(st);
	}
}

void Parser::function_heading(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_function_heading, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_function, false, "function_heading") ) addTerminal(st);
	if( expect(Tok_identifier, false, "function_heading") ) addTerminal(st);
	if( la.d_type == Tok_Dot ) {
		if( expect(Tok_Dot, false, "function_heading") ) addTerminal(st);
		if( expect(Tok_identifier, false, "function_heading") ) addTerminal(st);
	}
	if( FIRST_formal_parameter_list(la.d_type) ) {
		formal_parameter_list(st);
	}
	if( la.d_type == Tok_Colon ) {
		if( expect(Tok_Colon, false, "function_heading") ) addTerminal(st);
		result_type(st);
	}
}

void Parser::result_type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_result_type, la); st->d_children.append(tmp); st = tmp; }
	type_identifier(st);
}

void Parser::formal_parameter_list(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_formal_parameter_list, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lpar, false, "formal_parameter_list") ) addTerminal(st);
	formal_parameter_section(st);
	while( la.d_type == Tok_Semi || FIRST_formal_parameter_section(la.d_type) ) {
		if( la.d_type == Tok_Semi ) {
			if( expect(Tok_Semi, false, "formal_parameter_list") ) addTerminal(st);
		}
		formal_parameter_section(st);
	}
	if( expect(Tok_Rpar, false, "formal_parameter_list") ) addTerminal(st);
}

void Parser::formal_parameter_section(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_formal_parameter_section, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_parameter_declaration(la.d_type) ) {
		parameter_declaration(st);
	} else if( FIRST_procedure_heading(la.d_type) ) {
		procedure_heading(st);
	} else if( FIRST_function_heading(la.d_type) ) {
		function_heading(st);
	} else
		invalid("formal_parameter_section");
}

void Parser::parameter_declaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_parameter_declaration, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_var ) {
		if( expect(Tok_var, false, "parameter_declaration") ) addTerminal(st);
	}
	identifier_list(st);
	if( expect(Tok_Colon, false, "parameter_declaration") ) addTerminal(st);
	type_identifier(st);
}

void Parser::statement_sequence(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_statement_sequence, la); st->d_children.append(tmp); st = tmp; }
	statement(st);
	while( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "statement_sequence") ) addTerminal(st);
		statement(st);
	}
}

void Parser::statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_statement, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_label_(la.d_type) ) {
		label_(st);
		if( expect(Tok_Colon, false, "statement") ) addTerminal(st);
	}
	if( FIRST_simple_statement(la.d_type) || la.d_type == Tok_otherwise || la.d_type == Tok_Semi || la.d_type == Tok_end || la.d_type == Tok_Semi || la.d_type == Tok_end || la.d_type == Tok_until || la.d_type == Tok_Semi || la.d_type == Tok_Semi || la.d_type == Tok_else ) {
		if( FIRST_simple_statement(la.d_type) ) {
			simple_statement(st);
		}
	} else if( FIRST_structured_statement(la.d_type) ) {
		structured_statement(st);
	} else
		invalid("statement");
}

void Parser::simple_statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_simple_statement, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_assigOrCall(la.d_type) ) {
		assigOrCall(st);
	} else if( FIRST_goto_statement(la.d_type) ) {
		goto_statement(st);
	} else
		invalid("simple_statement");
}

void Parser::assigOrCall(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_assigOrCall, la); st->d_children.append(tmp); st = tmp; }
	variable_reference(st);
	if( la.d_type == Tok_ColonEq ) {
		if( expect(Tok_ColonEq, false, "assigOrCall") ) addTerminal(st);
		expression(st);
	}
}

void Parser::goto_statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_goto_statement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_goto, false, "goto_statement") ) addTerminal(st);
	label_(st);
}

void Parser::structured_statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_structured_statement, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_compound_statement(la.d_type) ) {
		compound_statement(st);
	} else if( FIRST_repetitive_statement(la.d_type) ) {
		repetitive_statement(st);
	} else if( FIRST_conditional_statement(la.d_type) ) {
		conditional_statement(st);
	} else if( FIRST_with_statement(la.d_type) ) {
		with_statement(st);
	} else
		invalid("structured_statement");
}

void Parser::compound_statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_compound_statement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_begin, false, "compound_statement") ) addTerminal(st);
	statement_sequence(st);
	if( expect(Tok_end, false, "compound_statement") ) addTerminal(st);
}

void Parser::repetitive_statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_repetitive_statement, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_while_statement(la.d_type) ) {
		while_statement(st);
	} else if( FIRST_repeat_statement(la.d_type) ) {
		repeat_statement(st);
	} else if( FIRST_for_statement(la.d_type) ) {
		for_statement(st);
	} else
		invalid("repetitive_statement");
}

void Parser::while_statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_while_statement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_while, false, "while_statement") ) addTerminal(st);
	expression(st);
	if( expect(Tok_do, false, "while_statement") ) addTerminal(st);
	statement(st);
}

void Parser::repeat_statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_repeat_statement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_repeat, false, "repeat_statement") ) addTerminal(st);
	statement_sequence(st);
	if( expect(Tok_until, false, "repeat_statement") ) addTerminal(st);
	expression(st);
}

void Parser::for_statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_for_statement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_for, false, "for_statement") ) addTerminal(st);
	variable_identifier(st);
	if( expect(Tok_ColonEq, false, "for_statement") ) addTerminal(st);
	initial_value(st);
	if( la.d_type == Tok_to ) {
		if( expect(Tok_to, false, "for_statement") ) addTerminal(st);
	} else if( la.d_type == Tok_downto ) {
		if( expect(Tok_downto, false, "for_statement") ) addTerminal(st);
	} else
		invalid("for_statement");
	final_value(st);
	if( expect(Tok_do, false, "for_statement") ) addTerminal(st);
	statement(st);
}

void Parser::initial_value(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_initial_value, la); st->d_children.append(tmp); st = tmp; }
	expression(st);
}

void Parser::final_value(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_final_value, la); st->d_children.append(tmp); st = tmp; }
	expression(st);
}

void Parser::conditional_statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_conditional_statement, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_if_statement(la.d_type) ) {
		if_statement(st);
	} else if( FIRST_case_statement(la.d_type) ) {
		case_statement(st);
	} else
		invalid("conditional_statement");
}

void Parser::if_statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_if_statement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_if, false, "if_statement") ) addTerminal(st);
	expression(st);
	if( expect(Tok_then, false, "if_statement") ) addTerminal(st);
	statement(st);
	if( la.d_type == Tok_else ) {
		if( expect(Tok_else, false, "if_statement") ) addTerminal(st);
		statement(st);
	}
}

void Parser::case_statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_case_statement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_case, false, "case_statement") ) addTerminal(st);
	expression(st);
	if( expect(Tok_of, false, "case_statement") ) addTerminal(st);
	if( FIRST_case_limb(la.d_type) ) {
		case_limb(st);
		while( ( peek(1).d_type == Tok_Semi && !( peek(2).d_type == Tok_end ) && !( peek(2).d_type == Tok_otherwise ) )  ) {
			if( expect(Tok_Semi, false, "case_statement") ) addTerminal(st);
			if( FIRST_case_limb(la.d_type) ) {
				case_limb(st);
			}
		}
	}
	if( ( ( peek(1).d_type == Tok_Semi || peek(1).d_type == Tok_otherwise ) && ( peek(2).d_type == Tok_begin || peek(2).d_type == Tok_case || peek(2).d_type == Tok_digit_sequence || peek(2).d_type == Tok_for || peek(2).d_type == Tok_goto || peek(2).d_type == Tok_identifier || peek(2).d_type == Tok_if || peek(2).d_type == Tok_otherwise || peek(2).d_type == Tok_repeat || peek(2).d_type == Tok_while || peek(2).d_type == Tok_with ) )  ) {
		otherwise_clause(st);
	}
	if( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "case_statement") ) addTerminal(st);
	}
	if( expect(Tok_end, false, "case_statement") ) addTerminal(st);
}

void Parser::case_limb(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_case_limb, la); st->d_children.append(tmp); st = tmp; }
	case_label_list(st);
	if( expect(Tok_Colon, false, "case_limb") ) addTerminal(st);
	statement(st);
}

void Parser::case_label_list(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_case_label_list, la); st->d_children.append(tmp); st = tmp; }
	constant(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "case_label_list") ) addTerminal(st);
		constant(st);
	}
}

void Parser::otherwise_clause(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_otherwise_clause, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "otherwise_clause") ) addTerminal(st);
	}
	if( expect(Tok_otherwise, false, "otherwise_clause") ) addTerminal(st);
	statement(st);
}

void Parser::with_statement(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_with_statement, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_with, false, "with_statement") ) addTerminal(st);
	variable_reference(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "with_statement") ) addTerminal(st);
		variable_reference(st);
	}
	if( expect(Tok_do, false, "with_statement") ) addTerminal(st);
	statement(st);
}

void Parser::actual_parameter_list(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_actual_parameter_list, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lpar, false, "actual_parameter_list") ) addTerminal(st);
	actual_parameter(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "actual_parameter_list") ) addTerminal(st);
		actual_parameter(st);
	}
	if( expect(Tok_Rpar, false, "actual_parameter_list") ) addTerminal(st);
}

void Parser::actual_parameter(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_actual_parameter, la); st->d_children.append(tmp); st = tmp; }
	expression(st);
}

void Parser::expression(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_expression, la); st->d_children.append(tmp); st = tmp; }
	simple_expression(st);
	if( FIRST_relational_operator(la.d_type) ) {
		relational_operator(st);
		simple_expression(st);
	}
}

void Parser::simple_expression(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_simple_expression, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_sign(la.d_type) ) {
		sign(st);
	}
	term(st);
	while( FIRST_addition_operator(la.d_type) ) {
		addition_operator(st);
		term(st);
	}
}

void Parser::term(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_term, la); st->d_children.append(tmp); st = tmp; }
	factor(st);
	while( FIRST_multiplication_operator(la.d_type) ) {
		multiplication_operator(st);
		factor(st);
	}
}

void Parser::factor(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_factor, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_At ) {
		if( expect(Tok_At, false, "factor") ) addTerminal(st);
		variable_reference(st);
	} else if( la.d_type == Tok_identifier ) {
		if( expect(Tok_identifier, false, "factor") ) addTerminal(st);
		while( FIRST_qualifier(la.d_type) || FIRST_actual_parameter_list(la.d_type) ) {
			if( FIRST_qualifier(la.d_type) ) {
				qualifier(st);
			} else if( FIRST_actual_parameter_list(la.d_type) ) {
				actual_parameter_list(st);
			} else
				invalid("factor");
		}
	} else if( FIRST_unsigned_number(la.d_type) ) {
		unsigned_number(st);
	} else if( la.d_type == Tok_string_literal ) {
		if( expect(Tok_string_literal, false, "factor") ) addTerminal(st);
	} else if( la.d_type == Tok_nil ) {
		if( expect(Tok_nil, false, "factor") ) addTerminal(st);
	} else if( FIRST_set_literal(la.d_type) ) {
		set_literal(st);
	} else if( la.d_type == Tok_Lpar ) {
		if( expect(Tok_Lpar, false, "factor") ) addTerminal(st);
		expression(st);
		if( expect(Tok_Rpar, false, "factor") ) addTerminal(st);
	} else if( la.d_type == Tok_not ) {
		if( expect(Tok_not, false, "factor") ) addTerminal(st);
		factor(st);
	} else
		invalid("factor");
}

void Parser::relational_operator(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_relational_operator, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Eq ) {
		if( expect(Tok_Eq, false, "relational_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_LtGt ) {
		if( expect(Tok_LtGt, false, "relational_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Lt ) {
		if( expect(Tok_Lt, false, "relational_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Leq ) {
		if( expect(Tok_Leq, false, "relational_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Gt ) {
		if( expect(Tok_Gt, false, "relational_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Geq ) {
		if( expect(Tok_Geq, false, "relational_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_in ) {
		if( expect(Tok_in, false, "relational_operator") ) addTerminal(st);
	} else
		invalid("relational_operator");
}

void Parser::addition_operator(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_addition_operator, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Plus ) {
		if( expect(Tok_Plus, false, "addition_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Minus ) {
		if( expect(Tok_Minus, false, "addition_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_or ) {
		if( expect(Tok_or, false, "addition_operator") ) addTerminal(st);
	} else
		invalid("addition_operator");
}

void Parser::multiplication_operator(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_multiplication_operator, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Star ) {
		if( expect(Tok_Star, false, "multiplication_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Slash ) {
		if( expect(Tok_Slash, false, "multiplication_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_Colon ) {
		if( expect(Tok_Colon, false, "multiplication_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_div ) {
		if( expect(Tok_div, false, "multiplication_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_mod ) {
		if( expect(Tok_mod, false, "multiplication_operator") ) addTerminal(st);
	} else if( la.d_type == Tok_and ) {
		if( expect(Tok_and, false, "multiplication_operator") ) addTerminal(st);
	} else
		invalid("multiplication_operator");
}

void Parser::variable_reference(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_variable_reference, la); st->d_children.append(tmp); st = tmp; }
	variable_identifier(st);
	while( FIRST_qualifier(la.d_type) || FIRST_actual_parameter_list(la.d_type) ) {
		if( FIRST_qualifier(la.d_type) ) {
			qualifier(st);
		} else if( FIRST_actual_parameter_list(la.d_type) ) {
			actual_parameter_list(st);
		} else
			invalid("variable_reference");
	}
}

void Parser::qualifier(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_qualifier, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_index(la.d_type) ) {
		index(st);
	} else if( FIRST_field_designator(la.d_type) ) {
		field_designator(st);
	} else if( FIRST_dereferencer(la.d_type) ) {
		dereferencer(st);
	} else
		invalid("qualifier");
}

void Parser::index(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_index, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lbrack, false, "index") ) addTerminal(st);
	expression_list(st);
	if( expect(Tok_Rbrack, false, "index") ) addTerminal(st);
}

void Parser::field_designator(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_field_designator, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Dot, false, "field_designator") ) addTerminal(st);
	field_identifier(st);
}

void Parser::dereferencer(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_dereferencer, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Hat, false, "dereferencer") ) addTerminal(st);
}

void Parser::set_literal(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_set_literal, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lbrack, false, "set_literal") ) addTerminal(st);
	if( FIRST_member_group(la.d_type) ) {
		member_group(st);
		while( la.d_type == Tok_Comma ) {
			if( expect(Tok_Comma, false, "set_literal") ) addTerminal(st);
			member_group(st);
		}
	}
	if( expect(Tok_Rbrack, false, "set_literal") ) addTerminal(st);
}

void Parser::member_group(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_member_group, la); st->d_children.append(tmp); st = tmp; }
	expression(st);
	if( la.d_type == Tok_2Dot ) {
		if( expect(Tok_2Dot, false, "member_group") ) addTerminal(st);
		expression(st);
	}
}

void Parser::type_(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_type_, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_simple_type(la.d_type) ) {
		simple_type(st);
	} else if( FIRST_string_type(la.d_type) ) {
		string_type(st);
	} else if( FIRST_structured_type(la.d_type) ) {
		structured_type(st);
	} else if( FIRST_pointer_type(la.d_type) ) {
		pointer_type(st);
	} else
		invalid("type_");
}

void Parser::simple_type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_simple_type, la); st->d_children.append(tmp); st = tmp; }
	if( ( peek(1).d_type == Tok_identifier && !( peek(2).d_type == Tok_2Dot ) )  ) {
		if( expect(Tok_identifier, false, "simple_type") ) addTerminal(st);
	} else if( FIRST_subrange_type(la.d_type) ) {
		subrange_type(st);
	} else if( FIRST_enumerated_type(la.d_type) ) {
		enumerated_type(st);
	} else
		invalid("simple_type");
}

void Parser::ordinal_type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_ordinal_type, la); st->d_children.append(tmp); st = tmp; }
	simple_type(st);
}

void Parser::string_type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_string_type, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_string, false, "string_type") ) addTerminal(st);
	if( expect(Tok_Lbrack, false, "string_type") ) addTerminal(st);
	size_attribute(st);
	if( expect(Tok_Rbrack, false, "string_type") ) addTerminal(st);
}

void Parser::size_attribute(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_size_attribute, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_unsigned_integer(la.d_type) ) {
		unsigned_integer(st);
	} else if( la.d_type == Tok_identifier ) {
		if( expect(Tok_identifier, false, "size_attribute") ) addTerminal(st);
	} else
		invalid("size_attribute");
}

void Parser::enumerated_type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_enumerated_type, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Lpar, false, "enumerated_type") ) addTerminal(st);
	identifier_list(st);
	if( expect(Tok_Rpar, false, "enumerated_type") ) addTerminal(st);
}

void Parser::subrange_type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_subrange_type, la); st->d_children.append(tmp); st = tmp; }
	constant(st);
	if( la.d_type == Tok_2Dot ) {
		if( expect(Tok_2Dot, false, "subrange_type") ) addTerminal(st);
	} else if( la.d_type == Tok_Colon ) {
		if( expect(Tok_Colon, false, "subrange_type") ) addTerminal(st);
	} else
		invalid("subrange_type");
	constant(st);
}

void Parser::structured_type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_structured_type, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_packed ) {
		if( expect(Tok_packed, false, "structured_type") ) addTerminal(st);
	}
	if( FIRST_array_type(la.d_type) ) {
		array_type(st);
	} else if( FIRST_record_type(la.d_type) ) {
		record_type(st);
	} else if( FIRST_set_type(la.d_type) ) {
		set_type(st);
	} else if( FIRST_file_type(la.d_type) ) {
		file_type(st);
	} else if( FIRST_class_type(la.d_type) ) {
		class_type(st);
	} else
		invalid("structured_type");
}

void Parser::array_type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_array_type, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_array, false, "array_type") ) addTerminal(st);
	if( expect(Tok_Lbrack, false, "array_type") ) addTerminal(st);
	index_type(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "array_type") ) addTerminal(st);
		index_type(st);
	}
	if( expect(Tok_Rbrack, false, "array_type") ) addTerminal(st);
	if( expect(Tok_of, false, "array_type") ) addTerminal(st);
	type_(st);
}

void Parser::index_type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_index_type, la); st->d_children.append(tmp); st = tmp; }
	ordinal_type(st);
}

void Parser::set_type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_set_type, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_set, false, "set_type") ) addTerminal(st);
	if( expect(Tok_of, false, "set_type") ) addTerminal(st);
	ordinal_type(st);
}

void Parser::file_type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_file_type, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_file, false, "file_type") ) addTerminal(st);
	if( la.d_type == Tok_of ) {
		if( expect(Tok_of, false, "file_type") ) addTerminal(st);
		type_(st);
	}
}

void Parser::pointer_type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_pointer_type, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_Hat, false, "pointer_type") ) addTerminal(st);
	type_identifier(st);
}

void Parser::class_type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_class_type, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_subclass, false, "class_type") ) addTerminal(st);
	if( expect(Tok_of, false, "class_type") ) addTerminal(st);
	if( FIRST_type_identifier(la.d_type) ) {
		type_identifier(st);
	} else if( la.d_type == Tok_nil ) {
		if( expect(Tok_nil, false, "class_type") ) addTerminal(st);
	} else
		invalid("class_type");
	if( FIRST_field_list(la.d_type) ) {
		field_list(st);
	}
	method_interface(st);
	while( FIRST_method_interface(la.d_type) ) {
		method_interface(st);
	}
	if( expect(Tok_end, false, "class_type") ) addTerminal(st);
}

void Parser::method_interface(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_method_interface, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_procedure_heading(la.d_type) ) {
		procedure_heading(st);
	} else if( FIRST_function_heading(la.d_type) ) {
		function_heading(st);
	} else
		invalid("method_interface");
	if( ( peek(1).d_type == Tok_Semi && peek(2).d_type == Tok_identifier )  ) {
		if( expect(Tok_Semi, false, "method_interface") ) addTerminal(st);
		if( expect(Tok_identifier, false, "method_interface") ) addTerminal(st);
	}
	if( expect(Tok_Semi, false, "method_interface") ) addTerminal(st);
}

void Parser::record_type(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_record_type, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_record, false, "record_type") ) addTerminal(st);
	if( FIRST_field_list(la.d_type) ) {
		field_list(st);
	}
	if( expect(Tok_end, false, "record_type") ) addTerminal(st);
}

void Parser::field_list(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_field_list, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_fixed_part(la.d_type) ) {
		fixed_part(st);
		if( ( peek(1).d_type == Tok_Semi && peek(2).d_type == Tok_case )  ) {
			if( expect(Tok_Semi, false, "field_list") ) addTerminal(st);
			variant_part(st);
		}
	} else if( FIRST_variant_part(la.d_type) ) {
		variant_part(st);
	} else
		invalid("field_list");
	if( la.d_type == Tok_Semi ) {
		if( expect(Tok_Semi, false, "field_list") ) addTerminal(st);
	}
}

void Parser::fixed_part(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_fixed_part, la); st->d_children.append(tmp); st = tmp; }
	field_declaration(st);
	while( ( peek(1).d_type == Tok_Semi && peek(2).d_type == Tok_identifier )  ) {
		if( expect(Tok_Semi, false, "fixed_part") ) addTerminal(st);
		field_declaration(st);
	}
}

void Parser::field_declaration(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_field_declaration, la); st->d_children.append(tmp); st = tmp; }
	identifier_list(st);
	if( expect(Tok_Colon, false, "field_declaration") ) addTerminal(st);
	type_(st);
}

void Parser::variant_part(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_variant_part, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_case, false, "variant_part") ) addTerminal(st);
	if( ( peek(1).d_type == Tok_identifier && peek(2).d_type == Tok_Colon )  ) {
		tag_field(st);
	}
	type_identifier(st);
	if( expect(Tok_of, false, "variant_part") ) addTerminal(st);
	variant(st);
	while( ( peek(1).d_type == Tok_Semi && !( ( peek(2).d_type == Tok_end || peek(2).d_type == Tok_Rpar ) ) )  ) {
		if( expect(Tok_Semi, false, "variant_part") ) addTerminal(st);
		variant(st);
	}
}

void Parser::tag_field(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_tag_field, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_identifier, false, "tag_field") ) addTerminal(st);
	if( expect(Tok_Colon, false, "tag_field") ) addTerminal(st);
}

void Parser::variant(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_variant, la); st->d_children.append(tmp); st = tmp; }
	case_label_list(st);
	if( expect(Tok_Colon, false, "variant") ) addTerminal(st);
	if( expect(Tok_Lpar, false, "variant") ) addTerminal(st);
	if( FIRST_field_list(la.d_type) ) {
		field_list(st);
	}
	if( expect(Tok_Rpar, false, "variant") ) addTerminal(st);
}

void Parser::field_identifier(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_field_identifier, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_identifier, false, "field_identifier") ) addTerminal(st);
}

void Parser::variable_identifier(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_variable_identifier, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_identifier, false, "variable_identifier") ) addTerminal(st);
}

void Parser::type_identifier(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_type_identifier, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_identifier, false, "type_identifier") ) addTerminal(st);
}

void Parser::identifier_list(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_identifier_list, la); st->d_children.append(tmp); st = tmp; }
	if( expect(Tok_identifier, false, "identifier_list") ) addTerminal(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "identifier_list") ) addTerminal(st);
		if( expect(Tok_identifier, false, "identifier_list") ) addTerminal(st);
	}
}

void Parser::expression_list(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_expression_list, la); st->d_children.append(tmp); st = tmp; }
	expression(st);
	while( la.d_type == Tok_Comma ) {
		if( expect(Tok_Comma, false, "expression_list") ) addTerminal(st);
		expression(st);
	}
}

void Parser::unsigned_integer(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_unsigned_integer, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_digit_sequence ) {
		if( expect(Tok_digit_sequence, false, "unsigned_integer") ) addTerminal(st);
	} else if( la.d_type == Tok_hex_digit_sequence ) {
		if( expect(Tok_hex_digit_sequence, false, "unsigned_integer") ) addTerminal(st);
	} else
		invalid("unsigned_integer");
}

void Parser::unsigned_number(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_unsigned_number, la); st->d_children.append(tmp); st = tmp; }
	if( FIRST_unsigned_integer(la.d_type) ) {
		unsigned_integer(st);
	} else if( la.d_type == Tok_unsigned_real ) {
		if( expect(Tok_unsigned_real, false, "unsigned_number") ) addTerminal(st);
	} else
		invalid("unsigned_number");
}

void Parser::sign(SynTree* st) {
	{ SynTree* tmp = new SynTree(SynTree::R_sign, la); st->d_children.append(tmp); st = tmp; }
	if( la.d_type == Tok_Plus ) {
		if( expect(Tok_Plus, false, "sign") ) addTerminal(st);
	} else if( la.d_type == Tok_Minus ) {
		if( expect(Tok_Minus, false, "sign") ) addTerminal(st);
	} else
		invalid("sign");
}

