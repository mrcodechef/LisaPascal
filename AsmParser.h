

// This file was automatically generated by Coco/R; don't modify it.
#if !defined(Asm_COCO_PARSER_H__)
#define Asm_COCO_PARSER_H__

#include <QStack>
#include <LisaPascal/AsmSynTree.h>


namespace Asm {


class PpLexer;
class Parser {
private:
	enum {
		_EOF=0,
		_T_Literals_=1,
		_T_Hash=2,
		_T_Amp=3,
		_T_Lpar=4,
		_T_Rpar=5,
		_T_Star=6,
		_T_Plus=7,
		_T_Comma=8,
		_T_Minus=9,
		_T_Slash=10,
		_T_Colon=11,
		_T_Semi=12,
		_T_Lt=13,
		_T_LtGt=14,
		_T_Eq=15,
		_T_Gt=16,
		_T_Hat=17,
		_T_Bar=18,
		_T_Tilde=19,
		_T_Keywords_=20,
		_T_ABCD=21,
		_T_ADD=22,
		_T_ADDA=23,
		_T_ADDI=24,
		_T_ADDQ=25,
		_T_ADDX=26,
		_T_ALIGN=27,
		_T_AND=28,
		_T_ANDI=29,
		_T_ASCII=30,
		_T_ASL=31,
		_T_ASR=32,
		_T_BCC=33,
		_T_BCHG=34,
		_T_BCLR=35,
		_T_BCS=36,
		_T_BEQ=37,
		_T_BGE=38,
		_T_BGT=39,
		_T_BHI=40,
		_T_BHS=41,
		_T_BLE=42,
		_T_BLO=43,
		_T_BLS=44,
		_T_BLT=45,
		_T_BMI=46,
		_T_BNE=47,
		_T_BPL=48,
		_T_BRA=49,
		_T_BSET=50,
		_T_BSR=51,
		_T_BTST=52,
		_T_BVC=53,
		_T_BYTE=54,
		_T_CHK=55,
		_T_CLR=56,
		_T_CMP=57,
		_T_CMPA=58,
		_T_CMPI=59,
		_T_CMPM=60,
		_T_DBEQ=61,
		_T_DBF=62,
		_T_DBRA=63,
		_T_DEF=64,
		_T_DIVS=65,
		_T_DIVU=66,
		_T_ELSE=67,
		_T_END=68,
		_T_ENDC=69,
		_T_ENDM=70,
		_T_EOR=71,
		_T_EORI=72,
		_T_EQU=73,
		_T_EXG=74,
		_T_EXT=75,
		_T_FUNC=76,
		_T_IF=77,
		_T_ILLEGAL=78,
		_T_INCLUDE=79,
		_T_JMP=80,
		_T_JSR=81,
		_T_LEA=82,
		_T_LINK=83,
		_T_LIST=84,
		_T_LONG=85,
		_T_LSL=86,
		_T_LSR=87,
		_T_MACRO=88,
		_T_MACROLIST=89,
		_T_MOVE=90,
		_T_MOVEA=91,
		_T_MOVEM=92,
		_T_MOVEP=93,
		_T_MOVEQ=94,
		_T_MULS=95,
		_T_MULU=96,
		_T_NBCD=97,
		_T_NEG=98,
		_T_NEGX=99,
		_T_NOLIST=100,
		_T_NOMACROLIST=101,
		_T_NOP=102,
		_T_NOPATCHLIST=103,
		_T_NOT=104,
		_T_OR=105,
		_T_ORG=106,
		_T_ORI=107,
		_T_PAGE=108,
		_T_PATCHLIST=109,
		_T_PEA=110,
		_T_PROC=111,
		_T_REF=112,
		_T_RESET=113,
		_T_ROL=114,
		_T_ROR=115,
		_T_RORG=116,
		_T_ROXL=117,
		_T_ROXR=118,
		_T_RTE=119,
		_T_RTR=120,
		_T_RTS=121,
		_T_SBCD=122,
		_T_SEG=123,
		_T_SNE=124,
		_T_STOP=125,
		_T_SUB=126,
		_T_SUBA=127,
		_T_SUBI=128,
		_T_SUBQ=129,
		_T_SUBX=130,
		_T_SWAP=131,
		_T_TAS=132,
		_T_TITLE=133,
		_T_TRAP=134,
		_T_TRAPV=135,
		_T_TST=136,
		_T_UNLK=137,
		_T_WORD=138,
		_T_Specials_=139,
		_T_number=140,
		_T_string=141,
		_T_ident=142,
		_T_substitute=143,
		_T_label=144,
		_T_Comment=145,
		_T_eol=146,
		_T_dotW=147,
		_T_dotL=148,
		_T_dotB=149,
		_T_dotS=150,
		_T_Eof=151,
		_T_MaxToken_=152
	};
	int maxT;

	int errDist;
	int minErrDist;

	void SynErr(int n, const char* ctx = 0);
	void Get();
	void Expect(int n, const char* ctx = 0);
	bool StartOf(int s);
	void ExpectWeak(int n, int follow);
	bool WeakSeparator(int n, int syFol, int repFol);
    void SynErr(int line, int col, int n, const char* ctx, const QString&, const QString& path );

public:
	PpLexer *scanner;
	struct Error
	{
		QString msg;
		int row, col;
		QString path;
	};
	QList<Error> errors;
	
	void error(int row, int col, const QString& msg, const QString& path)
	{
		Error e;
		e.row = row;
		e.col = col;
		e.msg = msg;
		e.path = path;
		errors.append(e);
	}

	Token d_cur;
	Token d_next;
	QList<Token> d_comments;
	struct TokDummy
	{
		int kind;
	};
	TokDummy d_dummy;
	TokDummy *la;			// lookahead token
	
	int peek( quint8 la = 1 );

    void RunParser();

    
Asm::SynTree d_root;
	QStack<Asm::SynTree*> d_stack;
	void addTerminal() {
		Asm::SynTree* n = new Asm::SynTree( d_cur ); d_stack.top()->d_children.append(n);
	}



	Parser(PpLexer *scanner);
	~Parser();
	void SemErr(const char* msg);

	void program();
	void line();
	void term();
	void size();
	void addrop();
	void expression();
	void directive();
	void statement();
	void argument();
	void filename();
	void macrodef();
	void mnemonic();
	void reg();
	void factor();
	void op();

	void Parse();

}; // end Parser

} // namespace


#endif

